# Default values for laravel-helm.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

strategy: {}
  # type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 0
  #   maxUnavailable: 1

nameOverride: ""
fullnameOverride: ""
imagePullSecrets: []

# Configure Laravel PHP-FPM container.
app:
  image:
    repository: "bitnami/php-fpm"
    pullPolicy: IfNotPresent
    tag: "8.1"

  name: laravel
  customer: dev

  laravelEnv: |
    APP_NAME=Laravel
    APP_ENV=local
    APP_KEY=
    APP_DEBUG=true
    APP_URL=http://localhost
    
    LOG_CHANNEL=stack
    LOG_DEPRECATIONS_CHANNEL=null
    LOG_LEVEL=debug
    
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=laravel
    DB_USERNAME=root
    DB_PASSWORD=
    
    BROADCAST_DRIVER=log
    CACHE_DRIVER=file
    FILESYSTEM_DISK=local
    QUEUE_CONNECTION=sync
    SESSION_DRIVER=file
    SESSION_LIFETIME=120
    
    MEMCACHED_HOST=127.0.0.1
    
    REDIS_HOST=127.0.0.1
    REDIS_PASSWORD=null
    REDIS_PORT=6379
    
    MAIL_MAILER=smtp
    MAIL_HOST=mailhog
    MAIL_PORT=1025
    MAIL_USERNAME=null
    MAIL_PASSWORD=null
    MAIL_ENCRYPTION=null
    MAIL_FROM_ADDRESS="hello@example.com"
    MAIL_FROM_NAME="${APP_NAME}"
    
    AWS_ACCESS_KEY_ID=
    AWS_SECRET_ACCESS_KEY=
    AWS_DEFAULT_REGION=us-east-1
    AWS_BUCKET=
    AWS_USE_PATH_STYLE_ENDPOINT=false
    
    PUSHER_APP_ID=
    PUSHER_APP_KEY=
    PUSHER_APP_SECRET=
    PUSHER_APP_CLUSTER=mt1
    
    MIX_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
    MIX_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
    
    MEDIA_DISK=s3
    
    APP_PUBLIC_URL=
    
    REM_SERVICES_TOKEN=
    REM_SERVICES_URL=
    
    STRIP_PATH=
    WEBHOOK_SECRET=
    
    GOOGLE_MAPS_GEOCODIGN_URL=""
    GOOGLE_MAPS_APIKEY=""
    
    SCOUT_QUEUE=true
    SCOUT_DRIVER=algolia
    ALGOLIA_APP_ID=
    ALGOLIA_SECRET=
  

  # Specify the Secret name to pull the .env file from.
  # If not specified, it defaults to "{release name}-env". It should
  # be a secret that contains an ".env" data key with the full
  # .env file that will be copied during pod creation.
  # The secret should be created by you before running the app.
  # envSecretName: ""

  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

  # Extra environment variables for the app container.
  extraEnv: []
  # - name: POD_NAME
  #   valueFrom:
  #     fieldRef:
  #       fieldPath: metadata.name

  # Extra volumes to mount on the container.
  extraVolumeMounts: []
  # - name: some-folder
  #   mountPath: /some/path

  # Configure the TCP healthcheck for the PHP-FPM process.
  # If enabled, Kubernetes will periodically check the PHP-FPM
  # process to be alive and to serve FCGI requests.
  healthcheck:
    enabled: true
    period: 5

  # For PHP-FPM, php-fpm_exporter is used. Enabling it will
  # attach automatically the container and will expose metrics on localhost:9253/metrics
  # for Prometheus to scrape.
  # Read more: https://github.com/hipages/php-fpm_exporter
  exporter:
    enabled: false

    image:
      repository: hipages/php-fpm_exporter
      pullPolicy: IfNotPresent
      tag: "2.0.1"

    resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 40m
    #   memory: 32Mi
    # requests:
    #   cpu: 40m
    #   memory: 32Mi

# Configure the in-pod NGINX container. This container will
# decode the fastcgi process from the PHP-FPM container
# and will reverse proxy it to the external service.
nginx:
  image:
    repository: bitnami/nginx
    pullPolicy: IfNotPresent
    tag: "latest"

  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

  # Extra volumes to mount on the container.
  extraVolumeMounts: []
  # - name: some-folder
  #   mountPath: /some/path

  # Configure the HTTP healthcheck for the Laravel app.
  # If enabled, ensure the given path in the Laravel app
  # returns a 200 OK when accessed. Implementing a healthcheck
  healthcheck:
    enabled: false
    period: 5
    path: /health

  # Specify the Config name to pull the nginx configuration from.
  # If not specified, it defaults to "{release name}-nginx-config".
  # This will be automatically be created for you.
  # configName: ""

  # If no configName is specified, this will be the config
  # applied to the NGINX in-pod container.
  config: |
    server {
      listen 0.0.0.0:8080;
      server_name test.laravel.com;
      index index.php index.html;
      
      root /app/public;
      location / {
          try_files $uri $uri/ /index.php?$query_string;
      }
      
      location ~ .php$ {
          # try_files $uri =404;
          fastcgi_split_path_info ^(.+.php)(/.+)$;
          fastcgi_pass test-laravel-app:9000;
          fastcgi_index index.php;
          include fastcgi_params;
          fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
          fastcgi_param PATH_INFO $fastcgi_path_info;
      }
  # For NGINX, nginx-prometheus-exporter is used. Enabling it will
  # attach automatically the container and will expose metrics on localhost:9113/metrics
  # for Prometheus to scrape.
  # Read more: https://github.com/nginxinc/nginx-prometheus-exporter
  exporter:
    enabled: false

    image:
      repository: nginx/nginx-prometheus-exporter
      pullPolicy: IfNotPresent
      tag: "0.9.0"

    resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 40m
    #   memory: 32Mi
    # requests:
    #   cpu: 40m
    #   memory: 32Mi

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

rbac:
  create: false
  rules: []
  #  - apiGroups:
  #      - ""
  #    resources:
  #      - pods
  #    verbs:
  #      - get
  #      - list

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  laravel:
    type: ClusterIP
    port: 9000

    annotations: {}
    # Set annotations for the service.
  nginx:
    type: ClusterIP
    port: 8080

    annotations: {}
    # Set annotations for the service.

ingress:
  enabled: true
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # class: "nginx"
  hosts:
    - host: test.laravel.com
      paths:
        - /
  tls: []
  # - secretName: chart-example-tls
  #   hosts:
  #     - chart-example.local

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

  behavior: {}
  # Set the behavior for the autoscaler.
  # https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-configurable-scaling-behavior

  # Custom Metrics will be appended to the default CPU/Memory resources (if they're enabled).
  customMetrics: []
  # - type: Pods
  #   pods:
  #     metric:
  #       name: phpfpm_process_utilization
  #     target:
  #       type: AverageValue
  #       averageValue: "50"

pdb:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 25%

nodeSelector: {}

tolerations: []

affinity: {}

# Extra volumes to attach to the deployment.
extraVolumes: []
# - name: some-folder
#   emptyDir: {}

# Extra containers to run in the deployment.
extraContainers: []

# Extra init containers to run in the deployment.
extraInitContainers: []

# Configure the Task Scheduler.
scheduler:
  # When enabling it, the chart will deploy a sidecar container in the same pod that
  # will run the "schedule:run" command each minute.
  enabled: true

  command:
    - php
    - artisan
    - schedule:work

  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

  # Configure the PHP healthcheck for the process.
  # If enabled, Kubernetes will periodically check the container
  # to see if it's still responsive.
  healthcheck:
    enabled: true
    period: 5

phpFpmConf:
  # Specify the Config name to pull the laravel.conf configuration from.
  # If not specified, it defaults to "{release name}-php-fpm-config".
  # This will be automatically be created for you if you do not specify it.
  # configName: ""

  content: |
    

# Configure the php.ini used for the PHP process.
# This will overwrite the default ones that exists in the container.
phpIni:
  # Specify the Config name to pull the php.ini configuration from.
  # If not specified, it defaults to "{release name}-php-ini-config".
  # This will be automatically be created for you if you do not specify it.
  # configName: ""

  # If no configName is specified, this will be the config
  # applied to the app container.
  content: |
    max_file_uploads = 30M
    post_max_size=40M